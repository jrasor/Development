50,51d49
< import org.firstinspires.ftc.robotcore.external.ClassFactory;
< import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;
53d50
< import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;
55d51
< import org.opencv.core.CvType;
71,72d66
< import java.util.Iterator;
< import java.util.List;
75c69
< import static org.firstinspires.ftc.teamcode.Pullbot.RingOrientationAnalysisPipeline.Stage.values;
---
> import static org.firstinspires.ftc.teamcode.PullbotNew.RingOrientationAnalysisPipeline.Stage.values;
108,109d101
<  * v 3.1  12/9/20 Sigmoid motion profiling added.
<  * v 3.2  12/16/20 Improved PID approach to Blue Tower Goal with Vuforia.
112c104
< public class Pullbot extends GenericFTCRobot {
---
> public class PullbotNew extends GenericFTCRobot {
114,215c106
<   /*                      --  Vision. --                       */
< 
<   public class ColorBlobDetector {
<     // Lower and Upper bounds for range checking in HSV color space
<     private Scalar mLowerBound = new Scalar(0);
<     private Scalar mUpperBound = new Scalar(0);
<     // Minimum contour area in percent for contours filtering
<     private  double mMinContourArea = 0.1;
<     // Color radius for range checking in HSV color space
<     private Scalar mColorRadius = new Scalar(25,50,50,0);
<     private Mat mSpectrum = new Mat();
<     private List<MatOfPoint> mContours = new ArrayList<MatOfPoint>();
< 
<     // Cache
<     Mat mPyrDownMat = new Mat();
<     Mat mHsvMat = new Mat();
<     Mat mMask = new Mat();
<     Mat mDilatedMask = new Mat();
<     Mat mHierarchy = new Mat();
< 
<     public void setColorRadius(Scalar radius) {
<       mColorRadius = radius;
<     }
< 
<     public void setHsvColor(Scalar hsvColor) {
<       double minH = (hsvColor.val[0] >= mColorRadius.val[0]) ? hsvColor.val[0]-mColorRadius.val[0] : 0;
<       double maxH = (hsvColor.val[0]+mColorRadius.val[0] <= 255) ? hsvColor.val[0]+mColorRadius.val[0] : 255;
< 
<       mLowerBound.val[0] = minH;
<       mUpperBound.val[0] = maxH;
< 
<       mLowerBound.val[1] = hsvColor.val[1] - mColorRadius.val[1];
<       mUpperBound.val[1] = hsvColor.val[1] + mColorRadius.val[1];
< 
<       mLowerBound.val[2] = hsvColor.val[2] - mColorRadius.val[2];
<       mUpperBound.val[2] = hsvColor.val[2] + mColorRadius.val[2];
< 
<       mLowerBound.val[3] = 0;
<       mUpperBound.val[3] = 255;
< 
<       Mat spectrumHsv = new Mat(1, (int)(maxH-minH), CvType.CV_8UC3);
< 
<       for (int j = 0; j < maxH-minH; j++) {
<         byte[] tmp = {(byte)(minH+j), (byte)255, (byte)255};
<         spectrumHsv.put(0, j, tmp);
<       }
< 
<       Imgproc.cvtColor(spectrumHsv, mSpectrum, Imgproc.COLOR_HSV2RGB_FULL, 4);
<     }
< 
<     public Mat getSpectrum() {
<       return mSpectrum;
<     }
< 
<     public void setMinContourArea(double area) {
<       mMinContourArea = area;
<     }
< 
<     public void process(Mat rgbaImage) {
<       Imgproc.pyrDown(rgbaImage, mPyrDownMat);
<       Imgproc.pyrDown(mPyrDownMat, mPyrDownMat);
< 
<       Imgproc.cvtColor(mPyrDownMat, mHsvMat, Imgproc.COLOR_RGB2HSV_FULL);
< 
<       Core.inRange(mHsvMat, mLowerBound, mUpperBound, mMask);
<       Imgproc.dilate(mMask, mDilatedMask, new Mat());
< 
<       List<MatOfPoint> contours = new ArrayList<MatOfPoint>();
< 
<       Imgproc.findContours(mDilatedMask, contours, mHierarchy, Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE);
< 
<       // Find max contour area
<       double maxArea = 0;
<       Iterator<MatOfPoint> each = contours.iterator();
<       while (each.hasNext()) {
<         MatOfPoint wrapper = each.next();
<         double area = Imgproc.contourArea(wrapper);
<         if (area > maxArea)
<           maxArea = area;
<       }
< 
<       // Filter contours by area and resize to fit the original image size
<       mContours.clear();
<       each = contours.iterator();
<       while (each.hasNext()) {
<         MatOfPoint contour = each.next();
<         if (Imgproc.contourArea(contour) > mMinContourArea*maxArea) {
<           Core.multiply(contour, new Scalar(4,4), contour);
<           mContours.add(contour);
<         }
<       }
<     }
< 
<     public List<MatOfPoint> getContours() {
<       return mContours;
<     }
<   }
< 
<   ColorBlobDetector colorBlobDetector = new ColorBlobDetector();
<   List<MatOfPoint> contours = colorBlobDetector.getContours();
< 
<   // Easy Open CV properties.
---
>   // Vision properties
225,230c116,117
<   // Vuforia properties.
<   public VuforiaLocalizer.Parameters parameters;
<   public VuforiaLocalizer vuforia;
<   public OpenGLMatrix lastLocation;
<   public static VuforiaLocalizer.CameraDirection CAMERA_CHOICE = BACK;
<   // Vuforia needs to know about the Field.
---
> 
>   // Field related constants.
239,242d125
<   // Vuforia needs to know about the camera placement.
<   public final float CAMERA_FORWARD_DISPLACEMENT  = 102.0f; // mm
<   public final float CAMERA_VERTICAL_DISPLACEMENT = 203.0f; // mm
<   public final float CAMERA_LEFT_DISPLACEMENT     = 0.0f;
244,248c127
< 
<   // Sensor members.
<   public ColorSensor colorSensor;
< 
<   /*                      --  Drive train. --                       */
---
>   /* Drive train. */
260,269d138
<   static final double DISTANCE_PER_TURN = DRIVE_WHEEL_DIAMETER * Math.PI;
<   /// 11.00" per second.
<   // NeveRest40 free run: 160 rpm. Go about 80% of that, so encoders work at
<   // high speed under load.
<   static final double MAX_MOTOR_RPM = 129;
<   static final double MAX_WHEEL_TURNS_PER_SECOND = MAX_MOTOR_RPM / 60; //2.15
<   static final double MAX_DRIVE_SPEED =
<       MAX_WHEEL_TURNS_PER_SECOND * DISTANCE_PER_TURN; // 23.64"/s
< 
<   /*                      --  Actuators. --                       */
276a146,155
>   // Pullbot specific sensor members.
>   public ColorSensor colorSensor;
>   public static VuforiaLocalizer.CameraDirection CAMERA_CHOICE = BACK;
>   /* local OpMode members. */
> 
>   // Initialization.
>   HardwareMap hwMap = null;
>   private LinearOpMode currentOpMode;
>   private ElapsedTime period = new ElapsedTime();
> 
278c157
<   public Pullbot() {
---
>   public PullbotNew() {
281c160
<   public Pullbot(LinearOpMode linearOpMode) {
---
>   public PullbotNew(LinearOpMode linearOpMode) {
285,288d163
<   // Initialization.
<   HardwareMap hwMap = null;
<   private LinearOpMode currentOpMode;
<   private ElapsedTime period = new ElapsedTime();
293a169
> 
303a180
> 
314,321d190
< 
<     VuforiaLocalizer.Parameters parameters =
<         new VuforiaLocalizer.Parameters(cameraMonitorViewId);
<     parameters.vuforiaLicenseKey = VUFORIA_KEY;
<     parameters.cameraDirection   = CAMERA_CHOICE;
<     parameters.useExtendedTracking = false;
<     vuforia =
<         ClassFactory.getInstance().createVuforia(parameters);
324,325c193,194
<     VuforiaTrackables targetsUltimateGoal =
<         vuforia.loadTrackablesFromAsset("UltimateGoal");
---
> 
> 
331d199
< 
347,353d214
<    *										Utility methods
<    */
<   private double temperedControl (double input) {
<     return Math.pow(input, 3.0);
<   }
< 
<   /*
357,364d217
<   static class WobblerOrientationAnalysisPipeline extends OpenCvPipeline {
< 
<     @Override
<     public Mat processFrame(Mat input) {
<       return null;
<     }
<   }
< 
525a379
> 
530c384
<    *										Drive Train properties
---
>    *										Drive Train methods
536a391,393
>   private double temperedControl (double input) {
>     return Math.pow(input, 3.0);
>   }
611c468,469
<   // Sigmoid profile for change of speed on a single motor.
---
>   // Sigmoid profile for change of speed on a single motor. Todo: test on two
>   //  segments.
630,643d487
<   // Sigmoid profile for change of speed on a robot with 2 motor drive train.
<   public void changeSpeedSigmoid (double period, double startingSpeed,
<                                   double targetSpeed, double correction) {
<     double time;
<     double speed;
<     double speedScale = targetSpeed - startingSpeed;
<     runtime.reset();
<     do {
<       time = runtime.time();
<       speed = startingSpeed + speedScale * (0.5 - 0.5 * Math.cos(Math.PI * time / period));
<       leftDrive.setPower(-speed - correction);
<       rightDrive.setPower(-speed + correction);
<     } while (time < period);
<   }
645,664c489,490
<   public double accelerateDistanceSigmoid (double distance2DoIt,
<                                          double startSpeed,
<                                     double endSpeed, double turnFudgeFactor) {
<     double time;
<     double speed;
<     double speedScale = endSpeed - startSpeed;
<     double averageSpeed = (startSpeed + endSpeed) / 2.0;
<     double time2DoIt = distance2DoIt / (averageSpeed * MAX_DRIVE_SPEED);
<     runtime.reset();
<     do {
<       time = runtime.time();
<       speed = startSpeed + speedScale * (0.5 - 0.5 * Math.cos(Math.PI * time / time2DoIt));
<       leftDrive.setPower(-speed * turnFudgeFactor);
<       rightDrive.setPower(-speed * 1.0 / turnFudgeFactor);
<     } while (time < time2DoIt);
<     return time2DoIt;
<   }
< 
<       //  This one requires no command layer to hardware layer translation.
<       //  Just continue going straight.
---
>   //  This one requires no command layer to hardware layer translation.
>   //  Just continue going straight.
717,749d542
<   public double turnArcRadiusSigmoid (double startSpeed, double endSpeed,
<                                     double arc, double radius){
<     double time;
<     double speed;
<     double leftSpeed, rightSpeed;
<     double speedScale = endSpeed - startSpeed;
<     double averageSpeed = (startSpeed + endSpeed) / 2.0;
<     // Todo: What if radius is negative?
<     double turnFudgeFactor =
<         (radius + DRIVE_WHEEL_SEPARATION/2.0) / radius;
<     double time2DoIt = arc / (averageSpeed * MAX_DRIVE_SPEED);
<     runtime.reset();
<     do {
<       time = runtime.time();
<       speed = startSpeed + speedScale * (0.5 - 0.5 * Math.cos(Math.PI * time / time2DoIt));
<       leftSpeed = -speed / turnFudgeFactor;
<       rightSpeed = -speed * turnFudgeFactor;
<       // Normalize speeds so greater is 1, and the lesser is scaled down by the lesser/greater ratio.
<       if (Math.abs(leftSpeed) > 1.0) {
<         rightSpeed = rightSpeed/ Math.abs(leftSpeed);
<         leftSpeed = Math.signum(leftSpeed); // was -1.0
<       }
<       if (Math.abs(rightSpeed) > 1.0) {
<         leftSpeed = leftSpeed/ Math.abs(rightSpeed);
<         rightSpeed = Math.signum(rightSpeed); // was -1.0
<       }
< 
<       leftDrive.setPower(leftSpeed);
<       rightDrive.setPower(rightSpeed);
<     } while (time < time2DoIt);
<     return time2DoIt;
<   }
< 
791,793c584,587
<     if (currentOpMode.gamepad1.left_trigger > 0) {
<       // nudge left wheel forward a little.
<       leftDrive.setPower(-NUDGE_SPEED);
---
>     if (currentOpMode.gamepad1.left_trigger > 0){
>       // nudge left wheel forward a little
>       //moveMotor(leftDrive, NUDGE_SPEED, NUDGE_INCHES);
>       leftDrive.setPower (-NUDGE_SPEED);
795,796c589,591
<     if (currentOpMode.gamepad1.right_trigger > 0) {
<       // nudge right wheel forward a little.
---
>     if (currentOpMode.gamepad1.right_trigger > 0){
>       // nudge right wheel forward a little
> 
799,805c594,600
<     if (currentOpMode.gamepad1.left_bumper) {
<       // nudge left wheel back a little.
<       leftDrive.setPower(NUDGE_SPEED);
<     }
<     if (currentOpMode.gamepad1.right_bumper) {
<       // nudge right wheel back a little.
<       rightDrive.setPower(NUDGE_SPEED);
---
>     if (currentOpMode.gamepad1.left_bumper){
>       // nudge left wheel back a little
>       leftDrive.setPower (NUDGE_SPEED);
>     }
>     if (currentOpMode.gamepad1.right_bumper){
>       // nudge right wheel back a little
>       rightDrive.setPower (NUDGE_SPEED);
810c605
<     //  Two sticks independently command two drive wheels.
---
>     //  Tank drive with the two sticks.
